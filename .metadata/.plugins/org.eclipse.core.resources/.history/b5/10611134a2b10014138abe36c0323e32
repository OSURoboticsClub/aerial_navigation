#include "opencv2/video/tracking.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/gpu/gpu.hpp"

#include <iostream>
#include <ctype.h>
#include <vector>
#include <sys/time.h>
#include <stdio.h>

using namespace cv;
using namespace cv::gpu;
using namespace std;

Mat image, frame0, frame1, gray, mask;
gpu::GpuMat gpu_image, gpu_frame0, gpu_frame1, gpu_gray, gpu_mask, prev_points, next_points;

Rect selection;
Point origin;
bool selectObject = false;
int trackObject = 0;

RNG rng(12345);

static void onMouse( int event, int x, int y, int, void* )
{
	if( selectObject )
	{
		selection.x = MIN(x, origin.x);
		selection.y = MIN(y, origin.y);
		selection.width = std::abs(x - origin.x);
		selection.height = std::abs(y - origin.y);

		selection &= Rect(0, 0, image.cols, image.rows);
	}

	switch( event )
	{
	case CV_EVENT_LBUTTONDOWN:
		origin = Point(x,y);
		selection = Rect(x,y,0,0);
		selectObject = true;
		break;
	case CV_EVENT_LBUTTONUP:
		selectObject = false;
		if( selection.width > 0 && selection.height > 0 )
			trackObject = -1;
		break;
	}
}
static void download(const GpuMat& d_mat, vector<Point2f>& vec)
{
	vec.resize(d_mat.cols);
	Mat mat(1, d_mat.cols, CV_32FC2, (void*)&vec[0]);
	d_mat.download(mat);
}

static void download(const GpuMat& d_mat, vector<uchar>& vec)
{
	vec.resize(d_mat.cols);
	Mat mat(1, d_mat.cols, CV_8UC1, (void*)&vec[0]);
	d_mat.download(mat);
}
int main( int argc, const char** argv )
{

	VideoCapture cap;
	Rect trackWindow;

	cap.open("/home/scott/Aerial/aerial_navigation/photos/SoccerGoal.MOV");

	if( !cap.isOpened() )
	{
		cout << "***Could not initialize capturing...***\n";
		return -1;
	}
	//GoodFeaturesToTrackDetector_GPU(maxCorners=1000, qualityLevel=0.01, minDistance=0.0, blockSize=3, useHarrisDetector=false, harrisK=0.04)
	gpu::GoodFeaturesToTrackDetector_GPU good(4, 0.2, 1.0, 3, true, 0.04);

	PyrLKOpticalFlow pyrLK;

	d_pyrLK.winSize.width = 1920;
	d_pyrLK.winSize.height = 1080;
	d_pyrLK.maxLevel = 1;
	d_pyrLK.iters = 1;

	namedWindow( "Good Features to Track Detector", 0 );
	setMouseCallback( "Good Features to Track Detector", onMouse, 0 );

	bool paused = false;
	cap >> frame0;
	paused = true;
	vector<Point2f> prevPts;
	for(;;)
	{
		if( !paused )
		{
			cap >> frame0;
			if( frame0.empty() )
				break;
		}

		frame0.copyTo(image);

		if( !paused )
		{
			gpu_frame0.upload(frame0);
			gpu::cvtColor(gpu_frame0, gpu_gray, COLOR_BGR2GRAY);

			if(trackObject < 0) {

				trackObject = 1;
			}
			if(trackObject){
				GpuMat gpumask(gpu_gray.size(), CV_8UC1, Scalar::all(0));
				gpumask(selection).setTo(Scalar::all(255));

				gpu::Laplacian(gpu_gray, gpu_gray, gpu_gray.depth(), 3, 1.0, BORDER_DEFAULT);
				//gpu_gray.download(gray);
				//imshow("lap",gray);
				good(gpu_gray, prev_points, gpumask);
				 GpuMat d_frame0(frame0);
				 GpuMat d_frame1(frame1);
				 GpuMat d_frame1Gray(frame1Gray);
				 GpuMat d_nextPts;
				 GpuMat d_status;

				 pyrLK.sparse(useGray ? d_frame0Gray : d_frame0, useGray ? d_frame1Gray : d_frame1, d_prevPts, d_nextPts, d_status);

			} else {
				good(gpugray, prev_points);
			}
			prevPts = vector<Point2f>(prev_points.cols);
			download(prev_points, prevPts);
		}

		for(int i = 0; i < prevPts.size(); i++){
			circle(image, prevPts[i], 4, Scalar(225, 60, 60), -1, 8, 0 );
		}
		if( trackObject < 0 )
			paused = false;
		if( selectObject && selection.width > 0 && selection.height > 0 )
		{
			Mat mask(image, selection);
			bitwise_not(mask, mask);
		}
		imshow( "Good Features to Track Detector", image );

		char c = (char)waitKey(10);
		if( c == 27 )
			break;
		switch(c)
		{
		case 'c':
		trackObject = 0;
		break;
		case 'p':
		paused = !paused;
		break;
		default:
			;
		}
	}

	return 0;
}
