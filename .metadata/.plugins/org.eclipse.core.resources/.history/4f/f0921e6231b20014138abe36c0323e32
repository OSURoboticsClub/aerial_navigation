#include "opencv2/video/tracking.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/gpu/gpu.hpp"

#include <iostream>
#include <ctype.h>
#include <vector>
#include <sys/time.h>
#include <stdio.h>

using namespace cv;
using namespace cv::gpu;
using namespace std;

Mat image, frame0, frame1, gray, mask;
GpuMat gpu_image, gpu_frame0, gpu_frame1, gpu_gray, gpu_mask;
GpuMat prev_points, next_points, flow_status;

Rect selection;
Point origin;
bool selectObject = false;
int trackObject = 0;

RNG rng(12345);

static void onMouse( int event, int x, int y, int, void* )
{
	if( selectObject )
	{
		selection.x = MIN(x, origin.x);
		selection.y = MIN(y, origin.y);
		selection.width = std::abs(x - origin.x);
		selection.height = std::abs(y - origin.y);

		selection &= Rect(0, 0, image.cols, image.rows);
	}

	switch( event )
	{
	case CV_EVENT_LBUTTONDOWN:
		origin = Point(x,y);
		selection = Rect(x,y,0,0);
		selectObject = true;
		break;
	case CV_EVENT_LBUTTONUP:
		selectObject = false;
		if( selection.width > 0 && selection.height > 0 )
			trackObject = -1;
		break;
	}
}
static void download(const GpuMat& d_mat, vector<Point2f>& vec)
{
	vec.resize(d_mat.cols);
	Mat mat(1, d_mat.cols, CV_32FC2, (void*)&vec[0]);
	d_mat.download(mat);
}
static void download(const GpuMat& d_mat, vector<uchar>& vec)
{
	vec.resize(d_mat.cols);
	Mat mat(1, d_mat.cols, CV_8UC1, (void*)&vec[0]);
	d_mat.download(mat);
}
static void drawArrows(Mat& frame, const vector<Point2f>& prevPts, const vector<Point2f>& nextPts, const vector<uchar>& status, Scalar line_color = Scalar(0, 0, 255))
{
    for (size_t i = 0; i < prevPts.size(); ++i)
    {
        if (status[i])
        {
            int line_thickness = 1;

            Point p = prevPts[i];
            Point q = nextPts[i];

            double angle = atan2((double) p.y - q.y, (double) p.x - q.x);

            double hypotenuse = sqrt( (double)(p.y - q.y)*(p.y - q.y) + (double)(p.x - q.x)*(p.x - q.x) );

            if (hypotenuse < 1.0)
                continue;

            // Here we lengthen the arrow by a factor of three.
            q.x = (int) (p.x - 3 * hypotenuse * cos(angle));
            q.y = (int) (p.y - 3 * hypotenuse * sin(angle));

            // Now we draw the main line of the arrow.
            line(frame, p, q, line_color, line_thickness);

            // Now draw the tips of the arrow. I do some scaling so that the
            // tips look proportional to the main line of the arrow.

            p.x = (int) (q.x + 9 * cos(angle + CV_PI / 4));
            p.y = (int) (q.y + 9 * sin(angle + CV_PI / 4));
            line(frame, p, q, line_color, line_thickness);

            p.x = (int) (q.x + 9 * cos(angle - CV_PI / 4));
            p.y = (int) (q.y + 9 * sin(angle - CV_PI / 4));
            line(frame, p, q, line_color, line_thickness);
        }
    }
}

int main( int argc, const char** argv )
{

	VideoCapture cap;
	Rect trackWindow;

	cap.open("/home/scott/Aerial/aerial_navigation/photos/SoccerGoal.MOV");

	if( !cap.isOpened() )
	{
		cout << "***Could not initialize capturing...***\n";
		return -1;
	}
	//GoodFeaturesToTrackDetector_GPU(maxCorners=1000, qualityLevel=0.01, minDistance=0.0, blockSize=3, useHarrisDetector=false, harrisK=0.04)
	gpu::GoodFeaturesToTrackDetector_GPU good(25, 0.1, 1.0, 3, true, 0.04);
	gpu::FAST_GPU fast(12, true, 0.05);

	PyrLKOpticalFlow pyrLK;

	pyrLK.winSize.width = 1920;
	pyrLK.winSize.height = 1080;
	pyrLK.maxLevel = 1;
	pyrLK.iters = 1;

	namedWindow( "Good Features to Track Detector", 0 );
	setMouseCallback( "Good Features to Track Detector", onMouse, 0 );

	bool paused = false;
	cap >> frame0;
	paused = true;
	vector<Point2f> prevPts, nextPts;
	vector<KeyPoint> kp;
	vector<uchar> status;
	for(;;)
	{
		if( !paused )
		{
			frame0.copyTo(frame1);
			cap >> frame0;
			if( frame0.empty() )
				break;
		}

		frame0.copyTo(image);

		if( !paused )
		{
			next_points.copyTo(prev_points);
			gpu_gray.copyTo(gpu_frame1);

			gpu_frame0.upload(frame0);
			gpu::cvtColor(gpu_frame0, gpu_gray, COLOR_BGR2GRAY);

			if(trackObject < 0) {

				trackObject = 1;
			}
			if(trackObject){
				gpu_mask = GpuMat(gpu_gray.size(), CV_8UC1, Scalar::all(0));
				gpu_mask(selection).setTo(Scalar::all(255));

				gpu::Laplacian(gpu_gray, gpu_gray, gpu_gray.depth(), 3, 1.0, BORDER_DEFAULT);
				//gpu_gray.download(gray);
				//imshow("lap",gray);
				//good(gpu_gray, next_points, gpu_mask);
				fast(gpu_gray, gpu_mask, next_points);

				//pyrLK.sparse(gpu_frame1, gpu_gray, prev_points, next_points, flow_status);

			}

			//prevPts = vector<Point2f>(prev_points.cols);
			//download(prev_points, prevPts);


			fast.downloadKeypoints(next_points, kp);
			drawKeypoints(image, kp, image, Scalar(255, 0, 0));
			//nextPts = vector<Point2f>(next_points.cols);
			//download(next_points, nextPts);

			//status = vector<uchar>(flow_status.cols);
			//download(flow_status, status);
			//drawArrows(image, prevPts, nextPts, status, Scalar(0, 0, 255));
		}


		if( trackObject < 0 )
			paused = false;
		if( selectObject && selection.width > 0 && selection.height > 0 )
		{
			Mat mask(image, selection);
			bitwise_not(mask, mask);
		}
		imshow( "Good Features to Track Detector", image );

		char c = (char)waitKey(10);
		if( c == 27 )
			break;
		switch(c)
		{
		case 'c':
		trackObject = 0;
		break;
		case 'p':
		paused = !paused;
		break;
		default:
			;
		}
	}

	return 0;
}
